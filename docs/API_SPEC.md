# API specification (automatically extracted)

_Source text:_ docs\RT-0119-ocr.txt

## Extracted snippets and candidate signatures

### Snippet 1

```
MACROFOR T: a Fortran code generator in MAPLE
```

### Snippet 2

```
Claude Gomez. MACROFOR T: a Fortran code generator in MAPLE. [Research Report] R T-0119,
```

### Snippet 3

```
@i(fflAllnt~
```

### Snippet 4

```
MACROFORT: A Fortran CODE
```

### Snippet 5

```
MACROFORT: a Fortran code geµerator in MAPLE
MACROFORT: un generateur de code Fortran dans MAPLE
```

### Snippet 6

```
the fir!lt o~e, MAPLE is not able to solve numerically a. problem using· its ,own functions. in the;
```

### Snippet 7

```
boucle~ ~o.mpliquees a J'.aide des bo11cles .vhile et until fournies,pa.r MACROFORT. ;Le code fOR- ,
TRAN genere peut,eti:e optimise. Nous donnons.deux.exemples d~utilisation"deMACROFOR.':(': ·
```

### Snippet 8

```
a fixed number of digits (which can be as big as we want). A few MAPLE functions deal with
```

### Snippet 9

```
Fortran. Also, there are numerical problem that MAPLE fails to solve (see 4). Then, it would
```

### Snippet 10

```
to do that (see 5).
2 Why using MACROFORT ?
```

### Snippet 11

```
> •: •ain(tan(x"' (y+1))•log(sin(x·1/y)) )+P1*x"' (x"'x)/(1, 23-abs(y))+expand( (1+x) "'6);
```

### Snippet 12

```
• :• - sin(-tan(x ) + ln(sin(x - 1/y))) + -+ 1 + S x
1.23 - abs(y)
```

### Snippet 13

```
> Fortran(Cexp•eJ);
exp• ·sin(-tan(x••(y+1))+alog(sin(x-1/y)))+Pi•x••x••x/(0,123E1-ab
+s(y))+1+6•x+10•x••2+10•x••3+6•x••4+x••6
So, we could use this function to generate the Fortran statements which do the symbolic
```

### Snippet 14

```
for the whole process. This can be done with MACROFORT.
3 MACROFORT
Actually, we have made a kind of macro Fortran we have called MACROFORT. A MAPLE
```

### Snippet 15

```
original version of MACROFORT was made for the computer algebra system MACSYMA (see (1)) .
. .To generate Fortran code by using MACROFORT, we have to build a MAPLE list. Each
```

### Snippet 16

```
we call a macro Fortran statement.
The syntax of a Fortran statement or of a macro Fortran statement in MACROFORT
```

### Snippet 17

```
exists) with a f at its end for a single Fortran statement or am at its end for a macro-Fortran
statement. These keywords correspond to what we call a MACROFORT single instruction or a
MACROFORT macro instruction.
3.1 MACROFORT single instructions
The MACROFORT single instructions are the following:
```

### Snippet 18

```
[functionf, type, name, list]
```

### Snippet 19

```
[subroutinef, name, list]
```

### Snippet 20

```
call name (list)
close (unit)·
```

### Snippet 21

```
label format (list)
```

### Snippet 22

```
type function name (list)
```

- Candidate API name: **name** (type: function)

### Snippet 23

```
if (condition) goto label
if (condition) then
```

### Snippet 24

```
parameter (list)
```

### Snippet 25

```
read (file, label) list
```

### Snippet 26

```
subroutine name (list)
write (file, label) list
The arguments of MACROFORT instructions are MAPLE names and you have to quote them
```

- Candidate API name: **name** (type: subroutine)

### Snippet 27

```
When "condition" appears as an argument of a MACROFORT instruction, you only have to
write it with MAPLE synta.x and MACROFORT will do Fortran translation. For instance:
```

### Snippet 28

```
the names NOT, AND and OR with a functional notation. For instance:
```

### Snippet 29

```
. [if.then.f,0R(a•b,N0T(c<d))J.
The label numbers are automatically generated by MACROFORT. When "label" appears as
an argument of a MACROFORT instruction, you have to put a MAPLE name. A same name
corresponds to a same label and MACROFORT will generate the label number. In fact we will see
latter (see 3.2) that we can always avoid using labels.
When "list" appears as an argument of a MACROFORT instruction, it corresponds to an
```

### Snippet 30

```
All this is also available for MACROFORT macro instructions. But for them no label is needed.
3.2 · MACROFORT macro instructions
The MACROFORT macro instructions are the following:
```

### Snippet 31

```
[functionm, type, name ,list, body Jist]
```

### Snippet 32

```
close (unit)
generates read (flle,label) var.list
label format (format.list)
```

### Snippet 33

```
~l!l.H~fOllt;ine@,name,Jist, bodyJist] generates. :. subroutine name (list)
```

- Candidate API name: **name** (type: subroutine)

### Snippet 34

```
label format (formatJist)
There are also the following macro instructions:·
```

### Snippet 35

```
J'he o,nly .difference with commonf and declare:f single instructions is that you can put these macros
everywhere in the list describing the program and MACRO:FORT put them at the right place in
```

### Snippet 36

```
of,.th~.i: p~Qgram. Th.e~e macros c:mly work within a programm, functionm or subroutinem macro
```

### Snippet 37

```
. Tluire are other v~ry .important macro instructions. We do not give the corresponding generated
```

### Snippet 38

```
First there are two macro instructions corresponding to WHILE and UNTIL loops. We explain
```

### Snippet 39

```
m1ist be. MAP_LE lists describing Fortran statements with MACROFORT syntax .
```

### Snippet 40

```
. (i:natrixm_,variabl~, matrix] is another. very useful macro instruction. It is used to make assig­
```

### Snippet 41

```
a:=array([[xA2,x-y],[x/y,xA2-1]]);
```

### Snippet 42

```
. 'v(2 ,2) = x••2-1
```

### Snippet 43

```
v(1,2) = x-y_
```

### Snippet 44

```
. _v(1, 1) = X**2
```

### Snippet 45

```
In fact, a great number of single instructions (for instance dof, iLtheri_f,-wr'itef . ) are
never used because macro instructions are better and by using them it is never necessary to use
```

### Snippet 46

```
There are global variables defined by MACROFORT.
comment is a logical variable. When it is true (default value) MACROFORT generates auto-
```

### Snippet 47

```
input is the logical unit number of standard input (the default is 5).
```

### Snippet 48

```
the lo~ical unit number of sta~~ar_4 qutput (the default ,is 6)~,
optimized is a logicar·varfable. When it is true (the default value is false) MAPLE optimizer
```

### Snippet 49

```
single (the default value) or double .
```

### Snippet 50

```
generates variables beg_inning:with the let_te1:/'f'.•. ~o-you can a~d a~ impl~~i t :do.ublepr.ecision(t)
```

### Snippet 51

```
3.4 Using MACROFORT
```

### Snippet 52

```
readlib(macrofort):
with(macrofort);
```

### Snippet 53

```
pushe is a new functio';Uor adding an element, to the end of a. list. pushe(<element>, '<list>');
```

### Snippet 54

```
the function.
```

### Snippet 55

```
their default va.li1es tc:i tlfo global variables used by MACROFORT and it initializes the various
counters used internally by MACROFORT (for label generation for example).
```

### Snippet 56

```
writeto('foo.Fortran');
init_genfor(); # INITIALIZATION OF MACROFORT
genfor(flist);
writeto(terminal);
```

### Snippet 57

```
:1(x1, . ,xn) 7 0
fn(X1, Xn) = 0
with x1 , •. , Xn belonging to R. We use the matrix notation defining the vectors X and F(X), and
```

### Snippet 58

```
F'(X) ~r (8/i) 8x· J n,n
```

### Snippet 59

```
while NORM(F(X)) > EPS do { where NORM computes the norm of F(X) }
< find Y solution of the linear system F'(X).Y = -F(X) >
```

### Snippet 60

```
4.2 MACROFORT program
We giye below a MAPLE function which generates a general Fortran program for solving a
non-linear system by using MACROFORT.
resol is a Fortran subroutine solving a linear system of equations.
```

### Snippet 61

```
# F[I] IS THE TABLE OF THE FUNCTIONS WITH THE VARIABLES X[J]
```

### Snippet 62

```
# N IS THE NUMBER OF FUNCTIONS AND VARIABLES
gen_newton := proc(ff,x,n)
```

### Snippet 63

```
jac := array(1 . n,1 . n);
```

### Snippet 64

```
jac[ii,jjJ := diff(ff[iiJ,x[jjJ)
```

### Snippet 65

```
pg:=[[declaref,real,[f(n),zj(n,n),x(n)J],
```

### Snippet 66

```
[[writem,output,[11 x(1 ,i3,1 ) = 11 ],[i]J,
[readm,input,[1 e14.71 ],[x(i)]]JJ];
for ii from 1 ton do pushe([equalf,f(i1)1 ff[ii]],ilinit1 ) od;
```

### Snippet 67

```
·. [dom, i ,·1,n; [equalf ,x(i) ,-f(i)+x(i)]]] ;·
for ii from 1 ton do pushe([equalf,f(ii),ff[ii]J,1 lwhile1 ) od;
pg:=[op(pg),
[[whilem,zno'rm(f,n) >= eps,linit,lwhile,1000],
[writem,outpu·t, [1 (2x,e14.7) 1 ], [x]]]];
```

### Snippet 68

```
# MAPLE list describing the subroutine computing the quadratic norm off
```

- Candidate API name: **computing** (type: subroutine)

### Snippet 69

```
fo:=[[declaref,real,[f(m)JJ,
```

### Snippet 70

```
[~om, i, 1,n, [equalf ,zno~m,znorm:t-f (i)**2]],
. [equalf ,znorm,sqrt(znorm)]];
fo:=[functionm,real,znorm,[f,m],fo];
```

### Snippet 71

```
writeto('newton.f');
init_genfor();
genfor(pg);
genfor(fo);
writeto(terminal);
```

### Snippet 72

```
F + a2(l - e°'3 F) = h2 - S - __ .;._. __ ._
```

### Snippet 73

```
arctan.,/r-re -In (hN) + ~In (h1 ))
```

### Snippet 74

```
= arctan ( 1/l)
1 M2 (71' (h2) (if . r- Ti T2 ) ' -2v 7f 4in ht + V ii;'arctanvr - klh1 + klh2
```

### Snippet 75

```
exp1:=h2-s-(f+a2•(1-exp(a3•f)))/a1:
exp2:=f-l•k•gr•(Pi•sqrt(h2/gr)•arctan(aqrt(r))/2-Pi•cai/4-log(hn/h2)+
log(h1/h2)/2)
```

### Snippet 76

```
exp3: ~arctan(.phi.•sqrt (gr/h2))-sqrt (h2/ gr)• (Pi:•log(h2/h1)/4+sqrt(gr/h2) • .
arctan(sqrt(r))-t1/k/l/h1+t2/k/l/h2)/2:
```

### Snippet 77

```
csi :=sqrt((h1-h2) /gr): ,:.·
```

### Snippet 78

```
f[1J := subs(Cop(data).,f=x[1] ,h2=x[2J ,phi•xC3]J ,exp1):
f [2]: = subs ( [op(data), fa;,x [1J ,h2=x [2] ,phi•x[3J J, exp2):
f[3J := subs([op(data) ,fl:!'x[1J ,h2=x[2l1 phi11x[3JJ ,exp3):,
# loading MACROFORT
readlib(macrofort):
with(macrofort):
```

### Snippet 79

```
gen.newton(f,x,3)i
```

### Snippet 80

```
We give below the Fortran program generated by MACROFORT.
```

### Snippet 81

```
real f(3),'zj(3,3),x(3)
write(S,1000)
1000 format('eps = ')
read(S,1001) eps
1,001. format(e14. 7)
```

### Snippet 82

```
c WHILE (eps<=znorm(f,3)) DO <WHILE_LIST> (1)
```

### Snippet 83

```
write(S,1003) i
1003 format('x(',i3,') = ')
read(S,1004) x(i)
1004 format(e14,7)
```

### Snippet 84

```
f(1) = x(2)-3984.0/306.0-x(1)/610+324,0/306,0•exp(-0.247E-2•
+x(l))
f(2) = x(1)-0.316E4•0.3141693E1•sqrt(x(2))/sqrt(360.0)•atan(
+sqrt(24-x(2))/sqrt(x(2)))+0.1676E4•0.3141693E1•sqrt(24-x(2))/sqrt(
+360.0)+0·.63E4•alog((x(2)+360•x(3)••2)/x(2))-0.316E4•alog(24/x(2))+
+12•sqrt(360.0)•sqrt(24-x(2))/x(2)
f(3) = atan(x(3)•sqrt(360,0)/sqrt(x(2)))-sqrt(x(2))/sqrt(360
+. O)• (0 .3141693E1*alog(x(2) /24)/4+sqrt(360 .O)/sqrt(x(2) )iliata.n(sqrt(
+24-x(2))/sqrt(x(2)))-0.2857143E-1+0.2E1/x(2))/2
```

### Snippet 85

```
if (eps.le.znorm(f,3)) then
```

### Snippet 86

```
if (nwhile1,le,maxwhile1) then
```

### Snippet 87

```
· 1 .' • \ • · . ·zj ~~ 1 2) :~ -x(3)•sqrt(360,0)/sqrt(x(2)••3)/(1+360•x(3)u2/x
\4(2))/2-1/~qrt(x(2))/sqrt(360,0)•(0.3141593E1•alog(x(2)/24)/4+sqrt(
+360.0)/sqrt(x(2))*atan(sqrt(24-x(2))/sqrt(x(2)))-0.2857143E-1+0.2E
+1/x(2))/4-sqrt(x(2))/sqrt(360,0)•(0.3141593E1/x(2)/4-sqrt(360,0)/s
```

### Snippet 88

```
+qrt(x(2)**3)*atan(sqrt(24-x(2))/sqrt(x(2)))/2+sqrt(360.0)/sqrt(x(2
+))*(-1/(sqrt(24-x(2)))/sqrt(x(2))/2-sqrt(24-x(2))/sqrt(x(2)••3)/2)
+/(1+(24-x(2))/x(2))-0.2E1/x(2)**2)/2
zj(3,3) = sqrt(360.0)/sqrt(x(2))/(1+360•x(3)••2/x(2))
zj(2,1) = 1
zj(1,3) = 0
zj(1,1) = -1.0/610.0~0.2623869E-2•exp(-0.247E-2•x(1))
zj(3,1) = 0
zj(2,3) = 0.4536E7*x(3)/(x(2)+360*x(3)••2)
zj(2,2) = -0.1575E4*0.3141593E1/sqrt(x(2))/sqrt(360.0)•ata
+n(sqrt(24-x(2))/sqrt(x(2)))-0.315E4•0.3141593E1•sqrt(x(2))/sqrt(36
+0.0)•(-1/(sqrt(24-x(2)))/sqrt(x(2))/2-sqrt(24-x(2))/sqrt(x(2)••3)/
+2)/(1+(24-x(2))/x(2))-0.7875E3*0.3141593E1/sqrt(24-x(2))/sqrt(360.
+0)+0.63E4*(1/x(2)-(x(2)+360*x(3)**2)/x(2)•*2)/(x(2)+360•x(3)••2)•x
+(2)+0.315E4/x(2)-6*sqrt(360.0)/sqrt(24-x(2))/x(2)-12•sqrt(360.0)•~
+qrt(24-x(2))/x(2)**2
zj(1,2) = 1
call resol(zj,f,3)
```

### Snippet 89

```
x(i) = -f(i)+x(i)
```

### Snippet 90

```
f(1) = x(2)-3984.0/305.0-x(1)/610+324.0/305.0•exp(-0.247E-
+2*X(1))
· f(2) = x(1)-0.315E4•0.3141593E1*sqrt(x(2))/sqrt(360.0)•ata
+n(sqrt(24-x(2))/sqrt(x(2)))+0.1575E4•0.3141593E1•sqrt(24-x(2))/sqr
+t(360.0)+0.63E4•alog((x(2)+360•x(3)**2)/x(2))-0.315E4*alog(24/x(2)
+)+12•sqrt(360.0)*sqrt(24-x(2))/x(2)
f(3) = atan(x(3)*sqrt(360.0)/sqrt(x(2)))-sqrt(x(2))/sqrt(3
+60.0)*(0.3141593E1*alog(x(2)/24)/4+sqrt(360.0)/sqrt(x(2))•atan(sqr
+t(24-x(2))/sqrt(x(2)))-0.2857143E-1+0.2E1/x(2))/2
```

### Snippet 91

```
write(6,1007)
1007 format(' maxwhile1 ')
```

### Snippet 92

```
WHILE LOOP END (1)
write(6,1008) x
format((2x,e14.7))
real function znorm(f,m)
```

### Snippet 93

```
real f(m)
```

### Snippet 94

```
znorm = znorm+f(i)••2
```

### Snippet 95

```
znorm = sqrt(znorm)
```

### Snippet 96

```
5 Example 2: A recursive function on a tree
```

- Candidate API name: **on** (type: function)

### Snippet 97

```
For example, we consider a binary tree with nodes labeled by a couple of integers ( i, j). ( 1, 1) is
the root of the tree, (2, 1) and (2, 2) are the children nodes of the root and recursively ( i + 1, 2j -1)
and ( i + 1, 2j) are the children nodes of node ( i, j). Node ( i, j) is at level i.
```

### Snippet 98

```
f-. _ { g(fi-1,½)
t,J - g(f._ .i±!.)
```

### Snippet 99

```
where g is a given function.
```

### Snippet 100

```
f(N, 1) . f(N, 2N-l ).
```

### Snippet 101

```
real f(n,m)
```

### Snippet 102

```
f(i,j)=g(f(i-1,(j+1)/2))
```

### Snippet 103

```
f(i,j)=g(f(i-1,j/2))
```

### Snippet 104

```
instead of 2N - 1 real values (5 times more storage for N equal to 10).
```

### Snippet 105

```
program arrays f1(1), f2(2), f3(4) and so on. But now it is very tricky to write the Fortran
```

### Snippet 106

```
It is easy to generate this program with MACROFORT. We suppose that a Fortran function
g has already been defined. The MAPLE function which generates the Fortran program is:
gen_func := proc(n)
```

### Snippet 107

```
pushe( [declaref, real, [f. i(2~,(i-1))ll, 'pg'·);
```

### Snippet 108

```
pushe([dom,j,1,2••(1-1)-1,2,
[equalf ,f. i(j) ,g(f. (i-1)(' (j+1) '/2) )Jl ,'pg'):
pushe([dom,j,2,2••(1-1)-1,2,
[equalf, f. i(j). ,g(f. (1-1)(j/2) )JJ; 'pg'):
```

### Snippet 109

```
writeto(1 func.f1 ):
ini t_genfor(): genfor(pg):
writeto(terminal):
```

### Snippet 110

```
real f1(1)
real f2(2).
real f3(4)
real f4(8)
```

### Snippet 111

```
f2(j) = g(f1((j+1)/2))
```

### Snippet 112

```
f2(j) = g(f1(j/2))
```

### Snippet 113

```
f3(j) = g(f2((j+1)/2))
```

### Snippet 114

```
f3(j) = g(f2(j/2))
```

### Snippet 115

```
f4(j) = g(f3((j+1)/2))
```

### Snippet 116

```
f4(j) = g(f3(j/2))
```

### Snippet 117

```
Fqr example the g function ca.n be dependent of the node of the tree where we compute the value
```

- Candidate API name: **ca** (type: function)

### Snippet 118

```
wavelet transforms and we want to compute modeling filters by Schur-Levinson recursions (see [21).
```

### Snippet 119

```
MACROFORT has been described. We have shown that it ls possible tQ make FORTaAN code
within MAPLE using it as a preprocessor for numerical analysis. Moreover MACROFORT has
```

-

_This file was generated automatically. Review and refine signatures before implementing._