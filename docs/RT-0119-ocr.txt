HAL Id: inria-00070047
https://inria.hal.science/inria-00070047v1
Submitted on 19 May 2006
HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in F rance or
abroad, or from public or private research centers.
L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.
MACROFOR T : a F ortran code generator in MAPLE
Claude Gomez
T o cite this version:
Claude Gomez. MACROFOR T : a F ortran code generator in MAPLE. [Research Report] R T-0119,
INRIA. 1990, pp.14. ￿inria-00070047￿

~~ ~~~ 
coo~ 
m~~ 
@i(fflAllnt~ 
, . ~ coo'ValLlroomuJ 
~--
. J .. B[PtiOO 
~~~~~ 
~ 
~~1~~ m ffi 11 
Rapport§ Technique§ 
N° 119 
Programme 5 
Automatique, Productique, 
Traitement du Signal et des Donnees 
MACROFORT : A FORTRAN CODE 
GENERATOR IN MAPLE 
Claude GOMEZ 
Mai1990 
111111111111111111111111111111111111111111111 
* R T . 8 1 1 9 * 

.• 
MACROFORT: a FORTRAN code geµerator in MAPLE 
MACROFORT : un generateur de code FORTRAN dans MAPLE 
Claude Gomez 
INRIA 
Domaine de Voluceau 
Rocquencourt - BPl05 
78153 Le Chesnay Cedex 
FRANCE 

Ab~tract 
MACRQFO.RT is a package added to MAPLE which permits complete FORTRAN 77-code gener~ 
ation::'Y~1Ue using M,t\CROFORT, the user stays in MAPLE. He no longer deals with FORTRAN: 
label nul'Ilbering. Complicate FORTRAN loops are easy todo because vhile·a.nd-until"cil.pabil~. 
ities e~f~~, 'in., lvfJ\CRQFORT. The.generated code can be:optimized. Two'· ex~ples are'given. ·In'· 
the fir!lt o~e, MAPLE is not able to solve numerically a. problem using· its ,own functions. in the; 
secontl' one, a natura.11:y recursive problem is easily solved by recufSiyely genera.ting a FORTRAN 
program. 
Resume;. 
MACR,Q,FORT est. un nouveau package de MAPLE qui permet.de generer·'du code FORTR.Atf 77 
sans sortfr d~ MAPLE.,Le11 etiqµe~tes FORTRAN deviennenfhiutiles et il·est po~s.ible ·de rllalfs.er des"· 
boucle~ ~o.mpliquees a J'.aide des bo11cles .vhile et until fournies,pa.r MACRO FORT. ;Le code fOR- , 
TRAN genere peut,eti:e optimise. Nous donnons.deux.exemples d~utilisation"deMACROFOR.':(': · 
Dans le ,p~ell}ier, MA,P.L_E I_le, peut pas .resoudre le probleme en utilisant ·ses propres .fonHions •~t · · 
dans !Ei deuxi~me un probleme recursif est facilement resolu par un programme FORTRAN'. ' ·'· 
~ .. · ·• . 

1 Why generating FORTRAN ? 
MAPLE is a computer algebra system and is well suited to handle symbolic computations. It is 
possible to perform numerical calculations in MAPLE as well with floating-point numbers with 
a fixed number of digits (which can be as big as we want). A few MAPLE functions deal with 
numerical computing, e.g. evalf and fsolve which permit numerical integrations and numerical 
solutions of equations. But the running time of MAPLE in pure numerical computing is not as 
good as the one of FORTRAN code. Moreover, if we want to write portable numerical software 
and give it to another user who does not have MAPLE, a good tractable language for industry is 
FORTRAN. Also, there are numerical problem that MAPLE fails to solve (see 4). Then, it would 
be nice to gather MAPLE and FORTRAN in order to use the capabilities of MAPLE for computer 
algebra and the capabilities of FORTRAN for numerical computing. 
We can use MAPLE as a preproc~ssor for numerical analysis. For instance when we have to 
do a lot of symbolic manipulations as performing derivatives, integrals, before writing FORTRAN 
code. 
Tliere: a.~e p_ro~lem~ whicq are naturally described i,n a recursiv~ way. :If _the problem is tail 
recursive, it is easy to solve it in FORTRAN by using iterations. If it is 1:i'ot, it is very complicated 
to do that (see 5). 
2 Why using MACROFORT ? 
There is a MAPLE procedure called fortran. It takes as argument a MAPLE expression and 
returns it in FORTRAN syntax. 
For instance we have : 
> •: •ain(tan(x"' (y+1))•log(sin(x·1/y)) )+P1*x"' (x"'x)/(1, 23-abs(y))+expand( (1+x) "'6); 
> 
(y + 1) Pi X 
X 
(x) 
• :• - sin(-tan(x ) + ln(sin(x - 1/y))) + -------------+ 1 + S x 
1.23 - abs(y) 
2 3 4 6 
+ 10 X + 10 X + 5 X + X 
> fortran(Cexp•eJ); 
exp• ·sin(-tan(x••(y+1))+alog(sin(x-1/y)))+Pi•x••x••x/(0,123E1-ab 
+s(y))+1+6•x+10•x••2+10•x••3+6•x••4+x••6 
So, we could use this function to generate the FORTRAN statements which do the symbolic 
calculations into a file and then merge it with the remaining pa.rt of the FORTRAN code. But 
we find this process not very easy because we have to use MAPLE, to create intermediate files, to 
write FORTRAN code in another file and to merge the files. It would be nice to stay in MAPLE 
for the whole process. This can be done with MACROFORT. 
3 MACROFORT 
Actually, we have made a kind of macro FORTRAN we have called MACROFORT. A MAPLE 
user can perform symbolic calculations and write FORTRAN code without leaving MAPLE. The 
2 

original version of MACRO FORT was made for the computer algebra system MACSYMA (see (1)) . 
. .To generate FORTRAN code by using MACROFORT, we have to build a MAPLE list. Each 
element.of.which corresponds to a single FORTRAN statements·orto a few FORTRAN statement 
we call a macro FORTRAN statement. 
The syntax of a FORTRAN statement or of a macro FORTRAN statement in MACROFORT 
is a MAPLE list where the first element is a keyword describing the statement, the optional other 
elements are relevant arguments. A keyword is made from the FORTRAN instruction name (when it 
exists) with a f at its end for a single FORTRAN statement or am at its end for a macro-FORTRAN 
statement. These keywords correspond to what we call a MACROFORT single instruction or a 
MACROFORT macro instruction. 
3.1 MACROFORT single instructions 
The MACROFORT single instructions are the following: 
[callf ,name,list] 
[closef, unit] 
[commentf, string] 
[commonf, name, list] 
[continuef ,label] 
[declare_f, type, list] 
[dof, label, index, start, 
[dof, label, index, start, 
[elsef] 
[endf] 
[endiff] 
end] 
end,step] 
[equalf, variable, expression] 
[forrnatf, label, list] 
[functionf, type, name, list] 
[gotof, label] 
[if ..goto..f, condition, label] 
[if _then..f, condition] 
[openf, unit, file, status] 
[parameterf, list] 
[programf, name] 
[readf, file, label, list] 
[returnf] 
[subroutinef, name, list] 
[writef ,file,label,list] 
generates 
generates 
generates c 
generates 
generates label 
generates 
generates 
generates 
generates 
generates 
generates 
call name (list) 
close (unit)· 
string 
common /name/ list 
continue 
type list 
do label, index=start, end 
do label, index=start, end, step 
else 
end 
endif 
generates 
generates 
generates 
generates 
generates 
generates 
generates 
variable=expression 
label format (list) 
generates 
generates 
generates 
generates 
generates 
generates 
type function name (list) 
goto label 
if (condition) goto label 
if (condition) then 
open (unit=unit, file= 1 file1 , 
status= 1 status') 
parameter (list) 
program name 
read (file, label) list 
return 
subroutine name (list) 
write (file, label) list 
The arguments of MACROFORT instructions are MAPLE names and you have to quote them 
if necessary .. 
When "condition" appears as an argument of a MACROFORT instruction, you only have to 
write it with MAPLE synta.x and MACROFORT will do FORTRAN translation. For instance: 
[if_then..f ,a>=b]. 
When you want to introduce logical operators not, and and or in a condition, you have to use 
the names NOT, AND and OR with a functional notation. For instance: 
3 

. [if.then..f,0R(a•b,N0T(c<d))J. 
The label numbers are automatically generated by MACRO FORT. When "label" appears as 
an argument of a MACROFORT instruction, you have to put a MAPLE name. A same name 
corresponds to a same label and MACROFORT will generate the label number. In fact we will see 
latter (see 3.2) that we can always avoid using labels. 
When "list" appears as an argument of a MACROFORT instruction, it corresponds to an 
· argument FORTRAN list which you have to write as a MAPLE list. For instance: 
[callf,foo,[a,b,c]J 
or 
[formatf,['2x,e14,7'],[x,yJJ. 
All this is also available for MACRO FORT macro instructions. But for them no label is needed. 
3.2 · MACROFORT macro instructions 
The MACROFORT macro instructions are the following: 
'tdom, inde~ I s'ta~t 'end I s'tep' dolist'j 
' ' • • I • ' • " ~ • 
[dom, index ,start ,end, do..listJ 
[functionm, type, name ,list, body Jist] 
.,, 
generates do la~el, index•start, end , step 
doJiet 
label continue 
generates do label, index•start, end 
generates 
doJist 
label continue 
type function name (list) 
•, body .list.· -· .. 
end 
[if .then.else.m, condition, then.list, elseJist] generates if· condition then 
then.list 
[if .then.m, condition, thenJist] 
[programm,name, bodyJistJ 
[openm, unit, file, status, bodyJist] 
[readrn, file, formatJist, varJistJ 
generates 
else 
elseJist 
endif 
if condition then 
thenJist 
endif 
generates program name 
body.list 
end 
generates open (unit•unlt, file= 'file', 
status= 'status') 
bodyJist 
close (unit) 
generates read (flle,label) var.list 
label format (format.list) 
4 

~l!l.H~fOllt;ine@,name,Jist, bodyJist] generates. :. subroutine name (list) 
bodyJist 
end 
:Cwri tern, file, formatJist, varJist] generates write ,Cfile,label),•:• va:dist 
label format (formatJist) 
There are also the following macro instructions:· 
[cornmonm, name ,list] generates 
[declarem, type,list] generates 
common /name/ list 
type·. list 
J'he o,nly .difference with commonf and declare:f single instructions is that you can put these macros 
everywhere in the list describing the program and MACRO:FORT put them at the right place in 
_th~~ g~11,erated FORTRAN code. This permits to declar~ a variable orily when it is used in the body 
of,,.th~.i: p~Qgram. Th.e~e macros c:mly work within a programm, functionm or subroutinem macro 
instruction, otherwise there are ignored. · 
. Tluire are other v~ry .important macro instructions. We do not give the corresponding generated 
FORTRAN code because it is complicated. · 
First there are two macro instructions corresponding to WHILE and UNTIL loops. We explain 
below their semantic with a PAS CAL like syntax: 
[whilem,condition,initJist, whileJist, while..max] 
<iuitJist> 
while condition do 
<whileJist> 
end. 
[untilm,condition,initJist, untilJist, until.max] 
<initJist> 
do <untilJist> 
until condition 
end. 
, . ".ma;,c_whi}e" an~L,\';max_until" arguments denote the. maximum number of iterations that the 
\VHILB.loop or the .UNTIL loop.will execute; When the ma~imum is reached,.the loop-stops and 
a· message is issued. 
:: l<<;ioJ,i~t", ".thenJist", ",elseJist", ,"body Jist", "initJist'.', "untilJist" and "whileJist" arguments 
m1ist be. MAP_LE lists describing FORTRAN statements with MACRO FORT syntax .. 
You can nest as many loops as you want . 
. (i:natrixm_,variabl~, matrix] is another. very useful macro instruction. It is used to make assig­
nl;ttio11s. of,,the elem,en_t~ of a. matrix. "variable" is the name of a.FORTRAN matrix and "matrix" 
is the name of a MAPLE matrix. '' : ') r · 
For example, after: 
a:=array([[xA2,x-y],[x/y,xA2-1]]); 
[ 2 
[ X 
a := [ 
[ 
[ xly. 
5 
] 
X - y ] 
] 
2 ] 
x - 1 ] 

[matrixm,v,a] generates: 
, .. -,.., . . ., 
.. 'v(2 ,2) = x••2-1 
•• J •• \, ·-~ {. ' • • • 
v(1,2) = x-y_ 
1
'vd,'1) =· x/y 
. ·: l .. 
. _v(1, 1) = X**2 
,),!, .I' l '• 
An example of the use of whi:lein an'a1inatrixm·is'gfvei1 in' sectio1{4. . . ,. : .·: .. · 
In fact, a great number of single instructions (for instance dof, iLtheri_f,-wr'itef ... ) are 
never used because macro instructions are better and by using them it is never necessary to use 
labels. 
3.3 Flags and global variables 
There are global variables defined by MACROFORT. 
comment is a logical variable. When it is true (default value) MACROFORT generates auto-
,, 'inatically FORTRAN comments. · · · ,-. · :-_· ··>. ·:, · 
input is the logical unit number of standard input (the default is 5). 
out~u~ ,i_s 
1
the lo~ical unit number of sta~~ar_4 qutput (the default ,is 6)~, 
optimized is a logicar·varfable. When it is true (the default value is false) MAPLE optimizer 
( optimize MAPL'E fuircti-oii)'is used when FORTRAN is generated. 
precision specifies single or double precision .in the generated FORTRAN program. It can be 
single (the default value) or double . 
.. 
When double precision is used with MAPLE optimizer, you must know that MAPLE optimizer 
generates variables beg_inning:with the let_te1:/'f'.•. ~o-you can a~d a~ impl~~i t :do.ublepr.ecision(t) 
decla.ra.tion in the FORTRAN code by using: 
[declaref, 'implicit dol:lbleprecision' , [' ( t) ']]. 
3.4 Using MACROFORT 
You have to }?ad M:<\CROFORT before ,u,si,~1g)t}Y issuing the co~1Aan4.~it. 
readlib(macrofort): 
with(macrofort); 
Then, three n,e\V, fu1wti9_11s ar1~ ,waila.!.>le;.-•'..: ,.: 
pushe is a new functio';Uor adding an element, to the end of a. list. pushe(<element>, '<list>'); 
do the job. Note that you have to quote <list> because it is an argument that is modified in 
the function. 
a. ? "' 
iniLgenfor must be used without argument before a new FOilTR.AN code generation. It gives 
their default va.li1es tc:i tlfo global variables used by MACRO FORT and it initializes the various 
counters used internally by MACRO FORT (for label generation for example). 
genfor-is the fuuct-io1v.vhic.h..-.really gencra.t,es.t.he FORTRAN code.= Its•argument-is-.the MAP-LE 
list clescrihi,ng.the.FORTiliAN. program. 
6 

In summary, to generate FORTRAN code in a file, you have to executes the following MAPLE 
commands: 
flist:=[ ... J; # LIST DESCRIBING THE FORTRAN PROGRAM 
writeto('foo.fortran'); 
init_genfor(); # INITIALIZATION OF MACROFORT 
genfor(flist); 
writeto(terminal); 
4 Example 1: Generalized Newton method 
4.1 Newton algorithm 
We want to solve a non-linear system with n equations and n unknowns: 
{ 
:1(x1, ... ,xn) 7 0 
fn(X1,,,,, Xn) = 0 
with x1 , •.. , Xn belonging to R. We use the matrix notation defining the vectors X and F(X), and 
the Jacobian matrix of the system F'(X)-a n by n matrix-as: 
F'(X) ~r (8/i) 8x· J n,n 
The well-known algorithm of Newton method is-in Pascal like syntax-: 
X := XO { where XO is an arbitrary vector } 
while NORM(F(X)) > EPS do { where NORM computes the norm of F(X) } 
< find Y solution of the linear system F'(X).Y = -F(X) > 
X := Y+X 
end • 
. The problem when encoding this algorithm in FORTRAN code is to compute the jacobian. 
4.2 MACROFORT program 
We giye below a MAPLE function which generates a general FORTRAN program for solving a 
non-linear system by using MACROFORT. 
resol is a FORTRAN subroutine solving a linear system of equations. 
# GENERALIZED NEWTON ALGORITHM 
# F[I] IS THE TABLE OF THE FUNCTIONS WITH THE VARIABLES X[J] 
# XIS THE GENERIC NAME OF THE VARIABLES X[J] 
# N IS THE NUMBER OF FUNCTIONS AND VARIABLES 
gen_newton := proc(ff,x,n) 
local ii, f, jj, m, jac, pg, linit, lwhile, fo, zj; 
# main program 
# jacobian matrix 
jac := array(1 .. n,1 .. n); 
7 

for ii from 1 ton do 
for jj from 1 ton do 
jac[ii,jjJ := diff(ff[iiJ,x[jjJ) 
od od; 
# MAPLE list describing the main program is in the variable pg 
pg:=[[declaref,real,[f(n),zj(n,n),x(n)J], 
[writem,output,[11 eps = 11 ],[]], 
[readm,input,[1 e14.71 ],[eps]J];· 
#. while· instruction · 
linit:=[[dom,i,1,n, 
[[writem,output,[11 x(1 ,i3,1 ) = 11 ],[i]J, 
[readm,input,[1 e14.71 ],[x(i)]]JJ]; 
for ii from 1 ton do pushe([equalf,f(i1)1 ff[ii]],ilinit1 ) od; 
lwhile:=[[matrixm,zj,jac], 
[callf,resol,[zj,f,n]], 
·. [dom, i ,·1,n; [equalf ,x(i) ,-f(i)+x(i)]]] ;· 
for ii from 1 ton do pushe([equalf,f(ii),ff[ii]J,1 lwhile1 ) od; 
pg:=[op(pg), 
[[whilem,zno'rm(f,n) >= eps,linit,lwhile,1000], 
[writem,outpu·t, [1 (2x,e14.7) 1 ], [x]]]]; 
pg:=[programm,new'ton,pgJ; 
# MAPLE list describing the subroutine computing the quadratic norm off 
# is in variable fo 
fo:=[[declaref,real,[f(m)JJ, 
[equalf,znorm,O.], 
[~om, i, 1,n, [equalf ,zno~m,znorm:t-f (i)**2]], 
.. [equalf ,znorm,sqrt(znorm)]]; 
fo:=[functionm,real,znorm,[f,m],fo]; 
# FORTRAN code generation 
writeto('newton.f'); 
init_genfor(); 
genfor(pg); 
genfor(fo); 
writeto(terminal); 
end: 
4.3 Application to a steel rolling problem 
•, .. ,,,. 
'The system w~ \\ia,1{t·'tcfidlvk is described by the equations: 
.!•,' ' ,· i ,;:-,·' 
F + a2(l - e°'3 F) = h2 - S - __ .;.._. __ ....._ 
= F-lkR (.'..r i,
1
arctan.,/r-re -In (hN) + ~In (h1 )) 
' : '· 2· V R . 4 h2 2 h2 
+ ReT1 · 
h2 
8 

= arctan ( 1/l) 
1 M2 (71' (h2) (if . r- Ti T2 ) ' -2v 7f 4in ht + V ii;'arctanvr - klh1 + klh2 
with 
· and with the following values of the parameters: a1 = 610, a2 = 648, aa = -.00247'., l = 1iso, 
k = .0014, R = 360, Ti = 12, T2 = 35, h1 = 24 and S = 12. 
. . This set of equations is the simplified description of the behavior of a. steel strip in a. stand of a 
hot strip rolling mill. 
, . If ·you want to solve it by using pure MAPLE, you cannot use sol v~ to obtain the analytic 
solu'tion because the equations are too complicated. Then, you can use faolve to solve numerically 
, the·problem. But fsol ve gives a bad solution which has no physical meaning. So you are obliged 
to use a FORTRAN program. 
The MAPLE program which generates the corresponding FORTRAN code is: 
# STEEL ROLLING 
# solution by Newton method 
# numerical values of parameters 
data:=[a1~610,a.2=648,a3=-.00247,1=1250,k•1.4•10 .. (·2),gr■ 360,t1•12, 
t2=35,h1=24,s=12]: 
# equations 
exp1:=h2-s-(f+a2•(1-exp(a3•f)))/a1: 
exp2:=f-l•k•gr•(Pi•sqrt(h2/gr)•arctan(aqrt(r))/2-Pi•cai/4-log(hn/h2)+ 
log(h1/h2)/2) 
+gr•csht1/h2: 
exp3:: ~arctan(.phi.•sqrt (gr/h2))-sqrt (h2/ gr)• (Pi:•log(h2/h1)/4+sqrt(gr/h2) • .. 
arctan(sqrt(r))-t1/k/l/h1+t2/k/l/h2)/2: 
r:=(h1-h2)/h2: 
csi :=sqrt((h1-h2) /gr): ,:.· 
hn:=h2+gr•phi -2: · ·,: 
# table of equations with the good,variables 
f[1J := subs(Cop(data).,f=x[1] ,h2=x[2J ,phi•xC3]J ,exp1): 
f [2] : = subs ( [op(data), fa;,x [1J ,h2=x [2] ,phi•x[3J J, exp2): 
f[3J := subs([op(data) ,fl:!'x[1J ,h2=x[2l1 phi11x[3JJ ,exp3):, 
# loading MACROFORT 
readlib(macrofort): 
with(macrofort): 
#,·reading·· and executing the MAPLE procedure generating the FORTRAN code, 
read gen.newton: 
gen.newton(f,x,3)i 
9 

4.4 Generated FORTRAN program 
We give below the FORTRAN program generated by MACROFORT. 
program newton '• 
real f(3),'zj(3,3),x(3) 
write(S,1000) 
1000 format('eps = ') 
read(S,1001) eps 
1,001. format(e14. 7) 
C 
c WHILE (eps<=znorm(f,3)) DO <WHILE_LIST> (1) 
C 
c WHILE LOOP INITIALIZATION 
C 
maxwhile1 = 1000 
nwhile1 = O 
do 1002, i=1,3 
write(S,1003) i 
1003 format('x(',i3,') = ') 
read(S,1004) x(i) 
1004 format(e14,7) 
1002 continue 
C· 
C 
f(1) = x(2)-3984.0/306.0-x(1)/610+324,0/306,0•exp(-0.247E-2• 
+x(l)) 
f(2) = x(1)-0.316E4•0.3141693E1•sqrt(x(2))/sqrt(360.0)•atan( 
+sqrt(24-x(2))/sqrt(x(2)))+0.1676E4•0.3141693E1•sqrt(24-x(2))/sqrt( 
+360.0)+0·.63E4•alog((x(2)+360•x(3)••2)/x(2))-0.316E4•alog(24/x(2))+ 
+12•sqrt(360.0)•sqrt(24-x(2))/x(2) 
f(3) = atan(x(3)•sqrt(360,0)/sqrt(x(2)))-sqrt(x(2))/sqrt(360 
+. O)• (0 .3141693E1*alog(x(2) /24)/4+sqrt(360 .O)/sqrt(x(2) )iliata.n(sqrt( 
+24-x(2))/sqrt(x(2)))-0.2857143E-1+0.2E1/x(2))/2 
c WHILE LOOP BEGINNING 
1006 continue 
C 
c WHILE LOOP TERMINATION TESTS 
if (eps.le.znorm(f,3)) then 
C 
C 
C 
if (nwhile1,le,maxwhile1) then 
NEW LOOP ITERATION 
nwhile1 = nwhile1+1 
c <WHILE_LIST> 
· 1 .' • \ • · .. ·zj ~~ 1 2) :~ -x(3)•sqrt(360,0)/sqrt(x(2)••3)/(1+360•x(3)u2/x 
\4(2))/2-1/~qrt(x(2))/sqrt(360,0)•(0.3141593E1•alog(x(2)/24)/4+sqrt( 
+360.0)/sqrt(x(2))*atan(sqrt(24-x(2))/sqrt(x(2)))-0.2857143E-1+0.2E 
+1/x(2))/4-sqrt(x(2))/sqrt(360,0)•(0.3141593E1/x(2)/4-sqrt(360,0)/s 
10 

C 
C 
C 
C 
C 
C 
C 
C 
+qrt(x(2)**3)*atan(sqrt(24-x(2))/sqrt(x(2)))/2+sqrt(360.0)/sqrt(x(2 
+))*(-1/(sqrt(24-x(2)))/sqrt(x(2))/2-sqrt(24-x(2))/sqrt(x(2)••3)/2) 
+/(1+(24-x(2))/x(2))-0.2E1/x(2)**2)/2 
zj(3,3) = sqrt(360.0)/sqrt(x(2))/(1+360•x(3)••2/x(2)) 
zj(2,1) = 1 
zj(1,3) = 0 
zj(1,1) = -1.0/610.0~0.2623869E-2•exp(-0.247E-2•x(1)) 
zj(3,1) = 0 
zj(2,3) = 0.4536E7*x(3)/(x(2)+360*x(3)••2) 
zj(2,2) = -0.1575E4*0.3141593E1/sqrt(x(2))/sqrt(360.0)•ata 
+n(sqrt(24-x(2))/sqrt(x(2)))-0.315E4•0.3141593E1•sqrt(x(2))/sqrt(36 
+0.0)•(-1/(sqrt(24-x(2)))/sqrt(x(2))/2-sqrt(24-x(2))/sqrt(x(2)••3)/ 
+2)/(1+(24-x(2))/x(2))-0.7875E3*0.3141593E1/sqrt(24-x(2))/sqrt(360. 
+0)+0.63E4*(1/x(2)-(x(2)+360*x(3)**2)/x(2)•*2)/(x(2)+360•x(3)••2)•x 
+(2)+0.315E4/x(2)-6*sqrt(360.0)/sqrt(24-x(2))/x(2)-12•sqrt(360.0)•~ 
+qrt(24-x(2))/x(2)**2 
zj(1,2) = 1 
call resol(zj,f,3) 
do 1006, i=1,3 
x(i) = -f(i)+x(i) 
1006 continue 
f(1) = x(2)-3984.0/305.0-x(1)/610+324.0/305.0•exp(-0.247E-
+2*X(1)) 
· f(2) = x(1)-0.315E4•0.3141593E1*sqrt(x(2))/sqrt(360.0)•ata 
+n(sqrt(24-x(2))/sqrt(x(2)))+0.1575E4•0.3141593E1•sqrt(24-x(2))/sqr 
+t(360.0)+0.63E4•alog((x(2)+360•x(3)**2)/x(2))-0.315E4*alog(24/x(2) 
+)+12•sqrt(360.0)*sqrt(24-x(2))/x(2) 
f(3) = atan(x(3)*sqrt(360.0)/sqrt(x(2)))-sqrt(x(2))/sqrt(3 
+60.0)*(0.3141593E1*alog(x(2)/24)/4+sqrt(360.0)/sqrt(x(2))•atan(sqr 
+t(24-x(2))/sqrt(x(2)))-0.2857143E-1+0.2E1/x(2))/2 
goto 1005 
else 
WHILE LOOP TERMINATION 
BYPASSING THE MAXIMUM ITERATION NUMBER 
write(6,1007) 
1007 format(' maxwhile1 ') 
1008 
end 
endif 
NORMAL WHILE LOOP TERMINATION 
endif 
WHILE LOOP END (1) 
write(6,1008) x 
format((2x,e14.7)) 
real function znorm(f,m) 
11 

C 
C 
real f(m) 
znorm = 0 
do 1009, i=1,3 
znorm = znorm+f(i)••2 
1009 continue 
znorm = sqrt(znorm) 
end 
5 Example 2: A recursive function on a tree 
It is possible to write FORTRAN program solving recursive problems. 
But it can be very tedious and very complicated to do it when the recursion is complicate<f. 
When the recursion is not so complicated, we can have other problems. 
For example, we consider a binary tree with nodes labeled by a couple of integers ( i, j). ( 1, 1) is 
the root of the tree, (2, 1) and (2, 2) are the children nodes of the root and recursively ( i + 1, 2j -1) 
and ( i + 1, 2j) are the children nodes of node ( i, j). Node ( i, j) is at level i. 
Assume we have the following sequence: 
fi,1 given 
f-. _ { g(fi-1,½) 
t,J - g(f._ .i±!.) 
' 1, 2 . 
where g is a given function. 
if j is even 
if j is odd 
We want to compute the values of the sequence up to a given level N, i.e. the 2N-t values 
f(N, 1) ... f(N, 2N-l ). 
To write the corresponding FORTRAN code, you only have to write two loops: 
real f(n,m) 
do 1,i=1,n 
do 2,j=1,2••(n-1)-1,2 
f(i,j)=g(f(i-1,(j+1)/2)) 
2 continue 
do 3,j=2,2••(n-1),2 
f(i,j)=g(f(i-1,j/2)) 
3 continue 
1 continue 
but the dimension m of the array f is 2N-t ! We have to keep the storage for N x 2N-I real values 
instead of 2N - 1 real values (5 times more storage for N equal to 10). 
A way to solve this problem is to have an array for each level, i.e. to have in the FORTRAN 
program arrays f1(1), f2(2), f3(4) and so on. But now it is very tricky to write the FORTRAN 
program. 
It is easy to generate this program with MACRO FORT. We suppose that a FORTRAN function 
g has already been defined. The MAPLE function which generates the FORTRAN program is: 
gen_func := proc(n) 
local i ,j ,pg; 
pg:=[]; 
12 

# declaration of tho arrays 
for i from 1 ton do 
pushe( [declaref, real, [f. i(2~,(i-1))ll, 'pg'·); 
iJJ; 
# loops for each array 
for 1 from 2 ton do 
pushe([dom,j,1,2••(1-1)-1,2, 
[equalf ,f. i(j) ,g(f. (i-1)(' (j+1) '/2) )Jl ,'pg'): 
pushe([dom,j,2,2••(1-1)-1,2, 
[equalf, f. i(j). ,g(f. (1-1)(j/2) )JJ; 'pg'): 
od; 
pg:=[programm,f;pg]: 
writeto(1 func.f1 ): 
ini t_genfor() : 
genfor(pg): 
writeto(terminal): 
end: 
The generated FORTRAN program for N equal to 4 is: 
program func 
real f1(1) 
real f2(2). 
real f3(4) 
real f4(8) 
C 
do 1000, j=1,1,2 
f2(j) = g(f1((j+1)/2)) 
1000 continue 
C 
C 
do 1001, j=2,2,2 
f2(j) = g(f1(j/2)) 
1001 continue 
C 
C 
do 1002, j=1,3,2 
f3(j) = g(f2((j+1)/2)) 
1002 continue 
C 
C 
do 1003, j=2,4,2 
f3(j) = g(f2(j/2)) 
1003 continue 
C 
C 
do 1004, j=l,7,2 
f4(j) = g(f3((j+1)/2)) 
13 
, :l•c•~•ix ot~ 
r' :· .: ;::-; 

1004 continue 
C 
C 
do 1005, j=2,8,2 
f4(j) = g(f3(j/2)) 
1005 continue 
C 
end 
Together with the previous problem of storage, we can have a ~u~h more complicated recurs\on1 
Fqr example the g function ca.n be dependent of the node of the tree where we compute the value 
of the sequence. Such a problem occurs in multiscale statistical signal prQcessing when using 
wavelet transforms and we want to compute modeling filters by Schur-Levinson recursions (see [21). 
Investigations to solve this problem are undertaken. 
6 Conclusion 
MACROFORT has been described. We have shown that it ls possible tQ make FORTaAN code 
within MAPLE using it as a preprocessor for numerical analysis. Moreover MACROFORT has 
shown its capability for: 
• solving numerical problems that MAPLE cannot manage 
• doing mathematical computations before numerical computath>n 
• solving storage problems in FORTRAN code for classes of recursive algorithms 
• solving numerically recursive algorithms. 
References 
[1] Chancelier J.P., Gomez C. and Quadrat J.P., MACllOFORT: a FORTRAN Code Gene1qtor 
in MACSYMA, MACSYMA Newsletter, 1987, 
[2] Basseville M. and Benveniste A., Multiscale Statistical Signal Processing, INllIA report 970, 
1989. 
lmprime en France 
par f . A . l' Jnstitut National de Recherche en In ormauque et cm utomataque 
~ 
·--